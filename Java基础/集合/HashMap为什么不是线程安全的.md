原因: 

* 如果多个线程同时使用put方法添加元素，而且假设正好存在两个put的key值发生了碰撞，即hash值一样，那么根据hashmap的实现，这两个key会添加到数组的同一个位置，这样会造成其中一个线程的put的数据会被覆盖；
* 如果多个线程同时检测到元素个数超过`数组大小*loadfactor`，这样会发生多个线程同时对Node数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋值给table，换言之，其他线程的都会丢失，并且各自线程的put数据也丢失了；
# Linux

## 一、Linux文件系统介绍

在 Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录**都被看作是一个文件**。也就是说在LINUX系统中有一个重要的概念：**一切都是文件**。

Linux支持的5种文件类型:

| 文件类型       | 描述                                                         | 示例                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 普通文件       | 用来在辅助设备(如磁盘)上存储信息和数据                       | 包含程序源代码、可执行程序、图片、声音、图像等               |
| 目录文件       | 用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名 | /root、/home                                                 |
| 链接文件       | **用于不同目录下文件的共享**                                 | 当创建一个已存在文件的符号链接时，系统就创建一个链接文件，这个链接文件指向已存在的文件 |
| 设备文件       | 用来访问硬件设备                                             | 包括键盘、硬盘、光驱、打印机等                               |
| 命名管道(FIFO) | 是一种特殊类型的文件、Linux系统下，**进程之间通信可以通过该文件完成** |                                                              |

## 二、linux运行级别
运行级别就是操作系统当前正在运行的功能级别。

级别是从`0`到`6`，具有不同的功能。这些级别定义在`/ect/inittab`文件中。

这个文件是init程序寻找的主要文件，最先运行的服务是那些放在`/ect/rc.d`目录下的文件。

Linux下的7个运行级别：

* `0`: 系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动，机器关闭。
* `1`: 单用户工作状态，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。
* `2`: **多用户状态**，没有NFS支持。
* `3`: **完整的多用户模式**，有NFS，登陆后进入**控制台命令行模式**。
* `4`: 系统未使用，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。
* `5`: X11控制台，登陆后进入图形GUI模式，XWindow系统。

**标准的Linux运行级别为5或者3**

## 三、运行级别原理

总结:

* 在目录`/etc/rc.d/init.d`下有许多服务器脚本程序，一般称为服务(service)
* 在`/etc/rc.d`下有7个名为rcN.d的目录，对应系统的7个运行级别
* `rcN.d`目录下都是一些符号链接文件，这些链接文件都指向init.d目录下的service脚本文件，命名规则为K+nn+服务名或S+nn+服务名，其中nn为两位数字。
* 系统会根据指定的运行级别进入对应的rcN.d目录，并按照文件名顺序检索目录下的链接文件：对于以K(Kill)开头的文件，系统将终止对应的服；对于以S(Start)开头的文件，系统将启动对应的服务
* **查看运行级别用**：`runlevel`
* 进入其它运行级别用：`init N`，如果`init 3`则进入终端模式，`init 5`则又登录图形GUI模式
* 另外`init 0`为关机，`init 6`为重启系统
  标准的Linux运行级别为3或5，如果是3的话，系统就在多用户状态；如果是5的话，则是运行着XWindow系统。不同的运行级别有不同的用处，也应该根据自己的不同情形来设置。例如，如果丢失了root口令，那么可以让机器启动进入单用户状态来设置。在启动后的lilo提示符下输入：
  `init=/bin/shrw`

这样就可以使机器进入运行级别1，并把root文件系统挂为读写。它会路过所有系统认证，让你使用passwd程序来改变root口令，然后启动到一个新的运行级。

## 四、Linux进程状态

Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？

**答案**：

* 1）、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号；
* 2）、暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作；
* 3）、就绪状态：在 `run_queue` 队列里的状态；
* 4）、运行状态：在 `run_queue` 队列里的状态；
* 5）、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起；
* 6）、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（`task_struct`）也释放掉；
* 7）、退出状态；

符号:
* `D` :   不可中断 Uninterruptible（usually IO）
* `R` :    正在运行，或在队列中的进程
* `S` :    处于休眠状态
* `T` :    停止或被追踪
* `Z` :    僵尸进程
* `W` :    进入内存交换（从内核 2.6 开始无效）
* `X` :    死掉的进程



## 五、僵尸进程、孤儿进程

　　我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

　　**孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。**

　　**僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。**

**3、问题及危害**

　　unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，**如果进程不调用wait / waitpid的话，** **那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。**

　　**孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上**，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。**因此孤儿进程并不会有什么危害。**

　　**任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。**这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

　　僵尸进程危害场景：

　　例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。